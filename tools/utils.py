"""
This is the first module to analyse an apk.
We will:
1. Decompile the malware and analyze its code in combination with ICFG to produce a feature file;
2. Identify malicious behavior node corresponding to the knowledge graph based on its feature file.
Finally, we can obtain what malicious behaviors the malware contains.

2023-10-19
"""

import glob
import re
import shutil

import django
import sys
import os

from django.db.models import Q

sys.path.append('../')

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'mwep.settings')

django.setup()

from common import models


def str_str_version2(str_id, flag):
    """
    function: According to the incoming string, the id is extracted, and then the corresponding feature name is found in the corresponding data table according to the id and flag
    :param str_id: An array of feature ids, but it's actually a string
    :param flag: Used to identify whether the query is for permission or api, 0 is for api, 1 is for permission
    :return str_list: An array of feature names
    """
    id_list = []
    str_list = []
    if str_id != '' and str_id != ' ':
        str_id = str_id.replace(' ', '')
        if str_id.find(','):
            id_list = str_id.split(',')
        else:
            id_list.append(str_id)
        if flag == 0:
            for one in id_list:
                try:
                    ans = models.augmentAPiIn.objects.get(apiID=int(one))
                    if ans:
                        str_list.append(ans.apiName)
                except:
                    # print('api id:' + one + 'is not found')
                    pass
        elif flag == 1:
            for one in id_list:
                ans = models.augmentPerIn.objects.get(id=int(one))
                if ans:
                    str_list.append(ans.perName)
                else:
                    # print('permission id:' + one + 'is not found')
                    pass
    return str_list


def analyse(data):
    pattern = re.compile('edge \[\n(.*?)]', re.S)
    return_edge_list = pattern.findall(data)
    pattern = re.compile('node \[\n(.*?)external', re.S)
    return_node_list = pattern.findall(data)
    return return_node_list, return_edge_list


def get_data(url):
    f = open(url, "r", encoding='utf-8')
    data = f.read()
    f.close()
    return data


def dict_list(demo_list, _flag):
    """
    :param demo_list: QuerySet，like：[{'perName': 'android.permission.ACCESS_BACKGROUND_LOCATION'}, {'perName': 'android.permission.ACCESS_COARSE_LOCATION'}]
    :param _flag: indicate permissions,apis or node
    :return a sample list
    """
    try:
        ret_list = []
        for i in demo_list:
            ret_list.append(i[_flag])
        return ret_list
    except:
        print('Error: dict_list throw a exception!')


def generate_cg(apk):
    """
    :param apk: apk file without path
    """
    apk_name = apk.split('.')[0]  # apk name

    apk=os.path.join('../webapp/uploadFiles/', apk)
    os.system('androguard cg ' + apk + ' -o ../detect/outputCG/' + apk_name + '.gml')
    file = os.path.join('../detect/outputCG/', apk_name + '.gml')
    return file, apk_name

def generate_cg_edit(file):
    """
    :param apk: complete folder and path
    """
    filename = os.path.split(file)[1]
    apk_name = filename.split('.')[0]  # apk name
    # shutil.rmtree('detect/outputCG')
    # os.mkdir('detect/outputCG')
    os.system('androguard cg ' + file + ' -o ../detect/outputCG/' + apk_name + '.gml')
    file = os.path.join('../detect/outputCG/', apk_name + '.gml')
    return file, apk_name

def gml_txt(gml_file, apk_name):
    """
    :param gml_file: a .gml file generated by generate_cg，the path is:  detect/outputCG/.gml
    :param apk_name:apk's name
    # :return: a .txt file generated from .gml file
    """
    # print('gml_file:', gml_file)
    # print('apk_name:', apk_name)
    new_file = apk_name + '.txt'
    os.rename(gml_file, '../detect/outputCG/' + new_file)


def do_feature_file(apk_name):
    """
    :function read feature file
    :param apk_name: apk name
    return the content of feature file
    """
    feature_filename = os.path.join('../detect/output_features/', apk_name + '_features.txt')
    feature_file = open(feature_filename, 'r', encoding='utf-8')
    data = feature_file.read()
    feature_file.close()
    return data


def api_sdk_sim(api_name, kg_apis):
    """
    take api level and similiar api into account
    :param api_name: api name, turn this api into the api stored in the knowledge graph
    """
    ret = api_name
    try:
        ans = models.augmentAPiIn.objects.get(apiName=api_name)
        if ans.addList != '' or ans.repList != '':
            addList = ans.addList
            repList = ans.repList
            # print('addList：', addList)
            # print('repList：', repList)
            if addList != '':
                add_obj = models.ApiSim.objects.get(id=int(addList))
                add_apis = add_obj.list
                add_apis = add_apis.split(',')
                for api in add_apis:
                    api = api.replace(' ', '')
                    if api in str(kg_apis):
                        # print('新增 by sim：',api)
                        ret = api
                        break
            if repList != '':
                rep_obj = models.ApiSDK.objects.get(id=int(repList))
                rep_apis = rep_obj.list
                rep_apis = rep_apis.split(',')
                for api in rep_apis:
                    api = api.replace(' ', '')
                    if api in str(kg_apis):
                        # print('新增 by sdk：', api)
                        ret = api
                        break
        else:
            # print('not find0：', )
            pass
    except:
        # print('not find：', tmp)
        pass

    return ret


def get_location_name(cg_function):
    """
    :function: get cfg file's location
    :param cg_function: complete information of method，e.g.Ljava/io/PrintStream;->println(Ljava/lang/String;)V
    """
    file_location = cg_function.split(';')[0]  # ag file location，e.g.Lcom/bbcc/eeff/App$1
    function_name = cg_function.split('>')[1].split('(')[0]  # method name
    if file_location[0] == 'L':
        file_location = file_location[1:]
    return file_location, function_name


def create_cfg(apk_name, function_name, class_location):
    """
    :function create cg file
    :param function_name: limited function name
    :param apk_name
    :param apks_location: where the apk file locates
    """
    copy_location = '../detect/output_augment/processing/'
    folder = copy_location + apk_name
    if not os.path.exists(folder + class_location):
        apk = os.path.join('../webapp/uploadFiles', apk_name + '.apk')  # like D:/input/apk01.apk
        # copy apk file to ../detect/output_augment/processing/xx
        folder = folder + '/'
        file = os.path.split(apk)[1]
        shutil.copy(apk, folder + file)
        copy_apk = os.path.join(folder, file)
        cmd = 'androguard decompile -o ' + folder + ' -f png -i ' + copy_apk + ' --limit ' + '"' + function_name + '"'
        os.system(cmd)


def FindFile(path, new_path, method_name, class_name, new_file_name):
    """
    find file and copy it to ../output_augment/processing...
    """
    # print('new file name:', new_file_name)
    for ipath in os.listdir(path):
        fulldir = os.path.join(path, ipath)
        if os.path.isfile(fulldir):
            file = os.path.split(fulldir)[1]
            filename = file.split('.')[0]
            pp = os.path.dirname(fulldir)
            new_file = pp + '/' + method_name + '.txt'
            if filename.find(new_file_name) != -1 and file.split('.')[-1] == 'ag':
                os.rename(fulldir, new_file)
                shutil.copy(new_file, new_path)
            elif filename.find('[') != -1:
                # a special case
                filename = filename.replace('[', '')
                if filename == new_file_name and file.split('.')[-1] == 'ag':
                    os.rename(fulldir, new_file)
                    shutil.copy(new_file, new_path)
        if os.path.isdir(fulldir):
            FindFile(fulldir, new_path, method_name, class_name, new_file_name)


def do_file_name(node):
    """
    return the correct ag file name
    """
    label = re.findall('label\s"L(.*?)\(', node)[0]
    label_spl = label.split('/')
    class_location = '/'.join(label_spl[0:-1])
    method_name = label_spl[-1].split(';->')[-1]
    class_name = label_spl[-1].split(';->')[0]
    whole = re.findall('label\s(".*?")', node)[0]
    fun_param = re.findall('\((.*?)\)', whole)[0].split(';')
    fun_param_str = ''
    for one in fun_param:
        if len(one) > 0:
            fun_param_str = fun_param_str + ' ' + one.split('/')[-1].strip()
    fun_param_str = fun_param_str.strip()
    try:
        return_param = re.findall('\)(.*?)\s\[', whole)[0].split(';')
    except Exception as e:
        return_param=re.findall('\)(.*?)"', whole)[0].split(';')
    ret_param_str = ''
    for one in return_param:
        if len(one) > 0:
            ret_param_str = ret_param_str + '' + one.split('/')[-1].strip()
    ret_param_str = ret_param_str.strip()
    if method_name == '<init>':
        filename = class_name + ' _init_ (' + fun_param_str + ')' + ret_param_str
    else:
        filename = class_name + ' ' + method_name + ' (' + fun_param_str + ')' + ret_param_str
    return class_location, class_name, method_name, filename


def create_cfg_specific(apk_name, node):
    """
    Generates all cfg under a particular class, reducing the time spent on generating cfg
    """
    class_location, class_name, method_name, filename = do_file_name(node)
    limitCmd = class_location + '/' + '.*?' + method_name + '.*?'
    new_limitCmd = class_location + '/' + class_name + '.*?'
    folder = '../detect/output_augment/processing/' + apk_name
    new_path = folder + '/' + class_location + '/' + class_name
    new_file = new_path + '/' + method_name + '.txt'
    if not os.path.exists(folder):
        os.mkdir(folder)
    if not os.path.exists(new_file) and not os.path.exists(new_path + '/' + method_name + '.ag'):
        print('Creating CFG file...')
        apk = os.path.join('../webapp/uploadFiles', apk_name + '.apk')  # like D:/input/apk01.apk
        apk_folder = '../detect/output_augment/apks/'
        file = os.path.split(apk)[1]
        shutil.copy(apk, apk_folder + file)
        copy_apk = os.path.join(apk_folder, file)

        cmd = 'androguard decompile -o ' + apk_folder + ' -f png -i ' + copy_apk + ' --limit ' + '"' + new_limitCmd + '"'
        os.system(cmd)

        if not os.path.isdir(new_path):
            os.makedirs(new_path)
        FindFile(apk_folder, new_path, method_name, class_name, filename)
        shutil.rmtree(apk_folder)
        os.mkdir(apk_folder)
        print('CFG creating completes!')

    elif os.path.exists(new_file):
        print('CFG txt file exists.')

    return new_file


def change_ag_txt(base_location, file_location):
    """
    :function turn ag to txt
    :param base_location: where the apk excutes androguard commands
    :param file_location: ag file's location related to api class
    :return cfg with txt format
    """
    if file_location[0] == 'L':
        file_location = file_location[1:]
    ag_path = os.path.join(base_location, file_location + '/')
    files = glob.glob(ag_path + '/*.ag')
    ag_file_name = ''
    for f in files:
        filename = os.path.split(f)[1]
        ag_file_name = filename.split('.')[0]  # ag file's name

    txt_file = ag_path + ag_file_name + '.txt'
    if os.path.exists(txt_file):
        return txt_file
    else:
        ag_file = ag_path + ag_file_name + '.ag'
        if os.path.exists(ag_file):
            os.rename(ag_file, txt_file)
            return txt_file
        else:
            return None


def change_ag_txt_plus(apkname, label):
    """
    find the cfg file of a method
    """
    base_location = '../detect/output_augment/processing/'


def search_graph_back(graph, start, end):
    """
    output paths from start node to end node
    """
    results = []
    generate_path_back(graph, [start], end, results)
    results.sort(key=lambda x: len(x))
    return results


def generate_path_back(graph, path, end, results):
    state = path[-1]
    if state == end:
        results.append(path)
        path = []
    else:
        try:
            for arc in graph[state]:
                if arc not in path:
                    generate_path_back(graph, path + [arc], end, results)
        except:
            # print('当前路径:', path)
            path.append(state)
            pass


def list_print(listdata):
    for one in listdata:
        print(one)


def find_relations_all(match_node_rel):
    """
        match path according to matched nodes
    """
    match_node = match_node_rel
    ret_path = []
    fullNodeIdList = []  # node id list
    for node in match_node:
        fullNodeIdList.append(node['nodeID'])
    # fullNodeIdList = fullNode[:]  # 复制列表，其中存储的是ID
    tmp = list()

    for node in match_node:
        nodeId = node['nodeID']
        # 1）query database
        try:
            ans = models.augmentRelIn.objects.filter(sourceID=nodeId)
            if ans:
                if len(tmp) == 0 or tmp[-1] != nodeId:
                    tmp.append(nodeId)
                ans = list(ans)
                for one in ans:
                    # 2）If there is a neighbor node, check whether the neighbor node also exists in the matching node list of the APK
                    if one.targetID in fullNodeIdList:
                        # 2.1)If yes, the neighbor node is added to the path list
                        # print('tmp:', tmp)
                        # print("Mathed path nodes：", str(nodeId) + "->" + str(one.targetID))
                        tmp.append(one.targetID)
                        # fullNodeIdList.remove(nodeId)
                        # fullNodeIdList.remove(one.targetID)
                        # print('tmp list:', tmp)
                        if len(tmp) > 1:
                            ret_path.append(tmp)
                            tmp = tmp[0:-1]
                            continue
                    else:
                        # 2.2)If not, skip it (as this is generally not the case)
                        continue
        except:
            pass
        tmp = []

    # 匹配出来的路径去重
    ret_path2 = []
    for one in ret_path:
        if one not in ret_path2:
            ret_path2.append(one)

    # 查找对应的语义
    ret_path = []  # 全部的路径
    # 返回带和不带malicious node的路径
    ret_path_malicious = []
    ret_path_others = []
    for nodelist in ret_path2:
        flag = 0  # 判断当前路径中是否有恶意节点，有为1，没有为0
        semantics = []
        for node in nodelist:  # 寻找对应的语义
            ans = models.augmentNodeIn.objects.get(nodeID=node)
            if ans.mark == '2':
                flag = 1
            semantic = ans.actionName
            semantics.append(semantic)
        ret_path.append({'path': nodelist, 'semantics': semantics})

        if flag == 0:  # 返回不带恶意节点的路径
            ret_path_others.append({'path': nodelist, 'semantics': semantics})
        elif flag == 1:  # 返回带恶意节点的路径
            ret_path_malicious.append({'path': nodelist, 'semantics': semantics})
        else:
            print('what error')

    return ret_path, ret_path_malicious, ret_path_others


def find_relations_in_KG(kgNode1, kgNode2):
    """
        match path according to matched nodes
    """
    ret = []
    # 1）query database
    try:
        ans = models.augmentRelIn.objects.filter(
            (Q(sourceID=kgNode1) & Q(targetID=kgNode2)) | (Q(sourceID=kgNode2) & Q(sourceID=kgNode1)))
        if ans:
            for one in ans:
                tmp = []
                # tmp.append(one['sourceAct'])
                tmp.append(one.sourceAct)
                tmp.append(one.targetAct)
                # tmp.append(one['targetAct'])
                if tmp not in ret:
                    ret.append(tmp)
    except:
        pass

    # try:
    #     ans = models.augmentRelIn.objects.filter(Q(sourceID=kgNode2) & Q(targetID=kgNode1))
    #     if ans:
    #         ans = list(ans)
    #         tmp = []
    #         tmp.append(ans[0]['sourceAct'])
    #         tmp.append(ans[0]['targetAct'])
    #         ret.append(tmp)
    # except:
    #     pass

    return ret

# print('find relation:',find_relations_in_KG(3,8))

def find_apk_file(folder_path, apk_name):
    for root, dirs, files in os.walk(folder_path):
        for file in files:
            if file == apk_name + '.apk':
                return os.path.join(root, file)
    return None

def find_xml_file(folder_path, apk_name):
    for root, dirs, files in os.walk(folder_path):
        for file in files:
            if file == apk_name + '.xml':
                return os.path.join(root, file)
    return None

