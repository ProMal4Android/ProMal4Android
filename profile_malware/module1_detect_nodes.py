"""
This is the first module to analyse an apk.
We will:
1. Decompile the malware and analyse its code in combination with ICFG to produce a feature file;
2. Identify malicious behavior node corresponding to the knowledge graph based on its feature file.
Finally, we can obtain what malicious behaviors the malware contains.

2023-10-19
"""

import re
import time

from operator import eq
from urllib.parse import urlparse

import django
import sys
import os
from profile_malware.program_analysis import forwardDataflow_plus, backwardDataflow_plus
from common.utils import analyse, get_data, generate_cg, gml_txt, do_feature_file, api_sdk_sim, create_cfg_specific

sys.path.append('../')

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'mwep.settings')

django.setup()

from common import models

from androguard.misc import AnalyzeAPK
import xml.etree.ElementTree as ET

# Global variables
KG_APIS = None
KG_PERS = None
KG_FEATURES = None
MAL_APIS = None
KG = None


def main_module1(apk_name, f, p1, p2, p3, p4, p5):
    global KG_APIS, KG_PERS, KG_FEATURES, MAL_APIS, KG
    KG_APIS = p1
    KG_PERS = p2
    KG_FEATURES = p3
    MAL_APIS = p4
    KG = p5
    if os.path.exists('../profile_malware/output_features/' + apk_name + '_features.txt') and os.path.exists(
            '../profile_malware/outputCG/' + apk_name + '.txt'):
        pass
    else:
        print('Generate call graph...')
        gml, apk_name = generate_cg(f)
        gml_txt(gml, apk_name)  # turn cg into txt
        genrate_feature_file(apk_name, f)  # generate features file

    match_nodes = indentify_behaviors(apk_name, KG_APIS, MAL_APIS, KG)
    return match_nodes


def alter_api(label_api):
    # print('alter api:', label_api)
    index = label_api.find('>')
    api_name = label_api[index + 1:]
    # print('api name:', api_name)
    try:
        qs = models.augmentAPiIn.objects.get(apiName__contains=api_name)
        return qs.apiName
    except:
        return ''


def get_id_from_label(label, data):
    # data = get_data(os.path.join('../detect/outputCG/', 'BaseBridge0' + '.txt'))
    # data = data.replace("\n", '')
    if re.findall('node\s\[\s+id\s(\d+)\s+label\s"' + label.replace('$', '\$'), data):
        ans = re.findall('node\s\[\s+id\s(\d+)\s+label\s"' + label.replace('$', '\$'), data)[0]
        return ans
    else:
        print('a?', label)


# get_id_from_label('Lcom/android/battery/a/su;->e')


def special_apis(d, data):
    start = time.time()
    ret = {}
    api_ids = []
    # special apis: ["android/os/Build$VERSION;->SDK","android/os/Build$VERSION;->RELEASE","android/os/Build$VERSION;->INCREMENTAL..."]
    obj = models.MalAPI.objects.filter(apiName__contains="android/os/Build")
    for one in obj:
        api_ids.append(one.apiID)
    # api_ids = [145,183,195]
    raw_string = r""
    search_patterns = []
    for id in api_ids:
        try:
            api_name = models.MalAPI.objects.get(apiID=id).apiName
            search_patterns.append(raw_string + api_name.replace('$', '\$'))
        except Exception:
            continue
    records = []
    for dex in d:
        for current_class in dex.get_classes():
            for method in current_class.get_methods():
                code = method.get_code()
                if code:
                    for instruction in code.get_bc().get_instructions():
                        for pattern in search_patterns:
                            if re.search(pattern, instruction.get_output()):
                                method_label = current_class.get_name() + '->' + method.get_name()
                                method_id = get_id_from_label(method_label, data)
                                if method_id in records:
                                    ret[method_id]['apis'].append(pattern.replace('\$', '$'))
                                else:
                                    ret[method_id] = {'apis': [pattern.replace('\$', '$')],
                                                      'method_label': method_label}
                                    records.append(method_id)
                                # ret.append({'api':pattern,'method_label':method_label,'id':})
                                # print(f"Found pattern '{pattern}' in method {method.get_name()}")

    end = time.time()
    print('Time of extracting special apis：', str(end - start))
    return ret


def genrate_feature_file(apk_name, apk_file):
    """
    Androguard Version: 3.3.5
        :function add re pattern, save time
        :param a .txt file generated from .gml
        :return feature_txt: a .txt file consists of key apis & permissions of an app
        """
    start_time = time.time()
    print('Generate feature file...')
    apk_path = "../webapp/uploadFiles/" + apk_file
    a, d, dx = AnalyzeAPK(apk_path)
    permissions = a.get_permissions()

    intent_filter = []
    try:
        manifest_xml = a.get_android_manifest_axml().get_xml()
        root = ET.fromstring(manifest_xml)
        manifest_string = ET.tostring(root, encoding="utf-8").decode("utf-8")
        ans = re.findall('"(android\.intent\..*?)"', manifest_string)
        if ans:
            for one in ans:
                if one not in intent_filter:
                    intent_filter.append(one)
    except Exception as e:
        print(e)

    feature_filename = os.path.join('../profile_malware/output_features/', apk_name + '_features.txt')
    feature_file = open(feature_filename, 'w', encoding='utf-8')
    # **********Write Information Belows*************
    # 1. write permissions
    for per in permissions:
        # if per in kg_permissions:
        feature_file.write(per + '\n')
    feature_file.write('\n')

    # 2. write permissions
    for int in intent_filter:
        feature_file.write(int + '\n')
    feature_file.write('\n')

    # 3. write apis through cg
    data = get_data(os.path.join('../profile_malware/outputCG/', apk_name + '.txt'))
    node_list, edge_list = analyse(data)
    data = data.replace("\n", '')

    osBuild = special_apis(d, data)
    for key, value in osBuild.items():
        feature_file.write(str(key) + ' - ' + value['method_label'] + ':\n')
        build_apis = value['apis']
        for each_api in build_apis:
            feature_file.write(each_api + '\n')
        feature_file.write('\n')

    has_record = []
    global MAL_APIS
    for index, node in enumerate(node_list):
        api = re.findall('label\s"(L.*?;->.*?)\(', node)
        if api:
            api = api[0]
            if api[0] == "L":
                api = api[1:]
            api = api.split('/')
            api = '/'.join(api)
            if api in str(MAL_APIS):  # stand api that in the kg
                try:
                    # include sensitive api
                    qy = models.sensitiveApi.objects.get(api=api)
                    if qy:
                        forward, idl = forwardDataflow_plus(index, data, node_list)
                        for father in idl:
                            if father not in has_record:
                                api_list = []
                                father_function = re.findall('label\s"(L.*?;->.*?)\(', node_list[father])[0]
                                brother_node, idb = backwardDataflow_plus(father, data, node_list)
                                for br in brother_node:
                                    label_api = ''
                                    if re.findall('L(.*?;->.*?)\(', br['label']):
                                        label_api = re.findall('L(.*?;->.*?)\(', br['label'])[0]
                                    elif re.findall('L(.*?;->.*?)<', br['label']):
                                        label_api = re.findall('L(.*?;->.*?)<', br['label'])[0]
                                    if label_api in str(MAL_APIS):
                                        api_list.append(label_api)
                                    # elif label_api[0:4] != 'java' and label_api[0:7] != 'android':
                                    #     alterone = alter_api(label_api)
                                    #     if len(alterone) > 0 and alterone in str(apis_from_test):
                                    #         api_list.append(alterone)
                                if len(api_list) > 0:
                                    has_record.append(father)
                                    feature_file.write(str(father) + ' - ' + father_function + ':\n')
                                    for api in api_list:
                                        feature_file.write(api + '\n')
                                    feature_file.write('\n')
                except Exception as e:
                    # ans = models.MalAPI.objects.filter(apiName=api)
                    # if ans:
                    #     # mark apis that cause sensitive behaviors
                    #     # if ans[0].mark == '1':
                    #     forward, idl = forwardDataflow_plus(index, data, node_list)
                    #     for father in idl:
                    #         if father not in has_record:
                    #             api_list = []
                    #             father_function = re.findall('label\s"(L.*?;->.*?)\(', node_list[father])[0]
                    #             brother_node, idb = backwardDataflow_plus(father, data, node_list)
                    #             for br in brother_node:
                    #                 label_api = ''
                    #                 if re.findall('L(.*?;->.*?)\(', br['label']):
                    #                     label_api = re.findall('L(.*?;->.*?)\(', br['label'])[0]
                    #                 elif re.findall('L(.*?;->.*?)<', br['label']):
                    #                     label_api = re.findall('L(.*?;->.*?)<', br['label'])[0]
                    #                 if label_api in str(MAL_APIS):
                    #                     api_list.append(label_api)
                    #                 # elif label_api[0:4] != 'java' and label_api[0:7] != 'android':
                    #                 #     alterone = alter_api(label_api)
                    #                 #     # print('alter one:', alterone)
                    #                 #     if len(alterone) > 0 and alterone in str(apis_from_test):
                    #                 #         api_list.append(alterone)
                    #             if len(api_list) > 0:
                    #                 has_record.append(father)
                    #                 feature_file.write(str(father) + ' - ' + father_function + ':\n')
                    #                 for api in api_list:
                    #                     feature_file.write(api + '\n')
                    #                 feature_file.write('\n')
                    pass
            elif api.find('abortBroadcast') != -1:
                if index not in has_record:
                    has_record.append(index)
                    father_function = re.findall('label\s"(L.*?;->.*?)\(', node_list[index])[0]
                    feature_file.write(str(index) + ' - ' + father_function + ':\n')
                    feature_file.write('android/content/BroadcastReceiver;->abortBroadcast' + '\n')
                    feature_file.write('\n')
        # if len(api_list) > 0:
        #     feature_file.write(str(father_id) + ' - ' + father_function + ':\n')
        #     for api in api_list:
        #         feature_file.write(api + '\n')
        #     feature_file.write('\n')

    feature_file.close()

    end_time = time.time()
    print('Time of extracting features：', str(end_time - start_time))


def is_valid_url(url):
    """
    Determine whether a string/url is a valid URL
    """
    try:
        result = urlparse(url)
        return all([result.scheme, result.netloc])
    except ValueError:
        return False


def indentify_behaviors(apk_name, kg_apis, mal_apis, kg):
    """
    :function: get all behaviors from the feature file
    :apk_name, app's name
    :return     match_node_rel: all nodes matched, may occur more than one time
                match_node_sin: all nodes matched which only occur one time
                match_node_for_path: extract behaviors from feature file and record their corresponding node id in call graph.
    """
    start_time = time.time()
    print('Identify behaviors...')
    perlist = []
    feature_data = do_feature_file(apk_name)
    data = feature_data.split("\n\n")

    cg_data = get_data(os.path.join('../profile_malware/outputCG/', apk_name + '.txt'))
    node_list, edge_list = analyse(cg_data)
    # *** 0. get permission id ***
    permissions = data[0].split('\n')
    for per in permissions:
        try:
            id = models.MalPermission.objects.get(perName=per).perID
            if id not in perlist:
                perlist.append(id)
        except:
            print('This permission couldn\'t be found：', per)
            pass
    intent_filters = data[1].split('\n')
    candidates = []  # possible nodes
    # read apis
    for one in data[2:-1]:
        apis = one.strip('\n').split('\n')[1:]
        apilist = []  # api id list in this block
        # 1. get api id, noting api sdk and api similar
        for api in apis:
            if api in kg_apis:
                pass
            else:
                api = api_sdk_sim(api, mal_apis)
            try:
                id = models.MalAPI.objects.get(apiName=api).apiID
                apilist.append(id)
            except:
                print('Api does not exist：', api)
                pass

        # 2. find candidate nodes
        cgID = one.strip('\n').split('\n')[0].split(' - ')[0]
        print('cgID:', cgID)
        for node in kg:
            # shallow copy
            detect_node = node.copy()
            tmp = apilist
            node_apiList = node['apiList']
            node_perList = node['perList']
            node_constStr = node['constStr']
            inset_api = list(set(node_apiList).intersection(set(tmp)))
            inset_per = list(set(node_perList).intersection(set(perlist)))
            inset_api.sort()
            inset_per.sort()
            node_apiList.sort()
            node_perList.sort()

            if (len(inset_api) > 0 or len(inset_per) > 0) and eq(inset_api, node_apiList) and eq(inset_per,
                                                                                                 node_perList):
                print('node:',node)
                constants = []
                node_conList=[]
                if node_constStr:
                    if node_constStr.find('&')!=-1:
                        node_conList=node_constStr.split(" & ")
                        for cstr in node_conList:
                            print('cstr:', cstr)
                            if cstr in intent_filters:
                                constants.append(cstr)
                            elif cstr.find('android.') == -1:
                                if cgID is not None:
                                    cfg_file = create_cfg_specific(apk_name, node_list[int(cgID)])
                                    if cfg_file is not None:
                                        if os.path.exists(cfg_file):
                                            cfg_file_data = get_data(cfg_file)
                                            pattern = re.compile(cstr, re.S)
                                            ans = pattern.findall(cfg_file_data)
                                            if ans:
                                                constants.append(cstr)
                        inset_const = list(set(node_conList).intersection(set(constants)))
                        inset_const.sort()
                        node_conList.sort()
                        if eq(inset_const, node_conList):
                            detect_node['cgID'] = int(cgID)
                            possible_nodes = detect_node
                            candidates.append(possible_nodes)
                            # for appi in inset_api:
                            #     apilist.remove(appi)
                    elif node_constStr.find(' || '):
                        node_conList=node_constStr.split(" || ")
                        flag=0
                        for cstr in node_conList:
                            if cstr in intent_filters:
                                flag=1
                            elif cstr.find('android.') == -1:
                                if cgID is not None:
                                    cfg_file = create_cfg_specific(apk_name, node_list[int(cgID)])
                                    if cfg_file is not None:
                                        if os.path.exists(cfg_file):
                                            cfg_file_data = get_data(cfg_file)
                                            pattern = re.compile(cstr, re.S)
                                            ans = pattern.findall(cfg_file_data)
                                            if ans:
                                                flag=1
                        if flag==1:
                            detect_node['cgID'] = int(cgID)
                            possible_nodes = detect_node
                            candidates.append(possible_nodes)
                            # for appi in inset_api:
                            #     apilist.remove(appi)
                else:
                    detect_node['cgID'] = int(cgID)
                    possible_nodes = detect_node
                    candidates.append(possible_nodes)


        # if possible_nodes:
        #     candidates.append(possible_nodes)
        # print('\n')
    end_time = time.time()
    print('Time of identify behaviors：', str(end_time - start_time))

    return candidates
